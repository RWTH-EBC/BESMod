import logging
import os.path
import sys
import time
from pathlib import Path
from typing import List, Type

import pandas as pd
from ebcpy import DymolaAPI
from ebcpy.utils.reproduction import CopyFile, save_reproduction_archive

from bes_rules.configs import StudyConfig
from bes_rules.configs.inputs import InputConfig
from bes_rules.simulation_based_optimization.base import SurrogateBuilder
from bes_rules.utils import multiprocessing_ as bes_rules_mp
from bes_rules.utils import notify

logger = logging.getLogger(__name__)
logger.setLevel("DEBUG")


def generate_modelica_package(save_path: Path, modifiers: list, names: list):
    package_content = f'''package ModelsToSimulate\n'''
    explicit_model_names = []
    for name, modifier in zip(names, modifiers):
        name = name.replace("-", "_").replace("(", "_").replace(")", "_")
        package_content += f'  model {name}\n' \
                           f'    extends {modifier};\n' \
                           f'  end {name};\n'
        explicit_model_names.append(f"ModelsToSimulate.{name}")
    package_content += 'end ModelsToSimulate;\n'
    new_path = save_path.joinpath('ModelsToSimulate.mo')
    with open(new_path, 'w') as f:
        f.write(package_content)
    return explicit_model_names, new_path


class InputVariations:

    def __init__(
            self,
            config: StudyConfig,
            simulation_based_optimizer_class: Type[SurrogateBuilder] = None,
            **kwargs
    ):
        import warnings
        warnings.warn(
            message="InputVariations was refactored to a function, "
                    "please use run_input_variations instead",
            category=DeprecationWarning
        )
        self.config = config
        self.kwargs = kwargs
        self.simulation_based_optimizer_class = simulation_based_optimizer_class

    def run(self):
        run_input_variations(
            config=self.config,
            surrogate_builder_class=self.simulation_based_optimizer_class,
            simulation_based_optimization_kwargs=self.kwargs
        )


def run_single_inputs_combination(
        input_config: InputConfig,
        model_name: str,
        config: StudyConfig,
        sim_api: DymolaAPI,
        use_mp: bool,
        surrogate_builder_class: Type[SurrogateBuilder],
        surrogate_builder_kwargs: dict = None,
        extra_packages: list = None,
        time_delay_to_start: float = 0
):
    """
    Executes the given surrogate builder for a specified combination of model inputs.

    This function can be executed from either the main process or a sub-process,
    depending on whether parallelization is used at the input variation or surrogate builder level.

    Args:
         input_config (InputConfig): The configuration for the model inputs.
         model_name (str): The name of the model to be set and used for simulation.
         config (StudyConfig): The study configuration containing simulation parameters.
         sim_api (DymolaAPI): The API interface for running simulations.
         use_mp (bool): True to use parallelization for surrogate building
         surrogate_builder_class (Type[SurrogateBuilder]): The class used to build the surrogate model.
         surrogate_builder_kwargs (dict, optional): Additional keyword arguments for the surrogate builder.
         extra_packages (list, optional): Additional packages to load if use_mp = True
         time_delay_to_start (float, optional):
            Additional time to wait to avoid port errors in Dymola if mp, default 0
    Returns:
        str: The path to the log file generated by the surrogate builder.
    """
    # Set new model name
    config.simulation.model_name = model_name
    if not use_mp:
        time.sleep(time_delay_to_start)
        sim_api = surrogate_builder_class.start_simulation_api(
            config=config,
            extra_packages=extra_packages,
            n_cpu=1,
            worker=bes_rules_mp.get_worker_idx()
        )
    else:
        # trigger translation
        sim_api.model_name = config.simulation.model_name
    if surrogate_builder_kwargs is None:
        surrogate_builder_kwargs = {}
    surrogate_builder = surrogate_builder_class(
        config=config,
        sim_api=sim_api,
        input_config=input_config,
        use_mp=use_mp,
        **surrogate_builder_kwargs
    )
    surrogate_builder.run()
    if not use_mp:
        sim_api.close()
    return surrogate_builder.get_log_path()


def run_input_variations(
        config: StudyConfig,
        surrogate_builder_class: Type[SurrogateBuilder] = None,
        run_inputs_in_parallel: bool = False,
        **kwargs
):
    # Input handling
    if surrogate_builder_class is None:
        from bes_rules.simulation_based_optimization import BESMod
        surrogate_builder_class = BESMod
    if config.test_only:
        config.n_cpu = 1
        config.simulation.sim_setup["stop_time"] = config.simulation.sim_setup.get("start_time", 0) + 86400 * 3
        config.base_path = config.base_path.parent.joinpath("__test_only_" + config.base_path.name)

    log_message = kwargs.pop("log_message", config.name)

    def notify_on_exception(exc_type, exc_value, exc_traceback):
        error_message = (f"An error occurred in study {config.name}: "
                         f"{exc_type.__name__}: {exc_value}")
        notify.notify_telegram(error_message)
        sys.__excepthook__(exc_type, exc_value, exc_traceback)

    # Replace the default exception handler
    sys.excepthook = notify_on_exception

    config.inputs.generate_files(
        path=config.study_path,
        name=config.name
    )

    # Store for later usage:
    config_files = config.to_json()

    # Run all cases:
    permutations = config.inputs.get_permutations()
    if config.test_only and config.inputs.full_factorial:
        permutations = [permutations[0]]
    # Create package to simulate first for debugging
    model_names = [
        input_config.get_modelica_modifier(model_name=config.simulation.get_unmodified_model_name())
        for input_config in permutations
    ]
    explicit_model_names, new_package = generate_modelica_package(
        save_path=config.study_path,
        modifiers=model_names,
        names=[input_config.get_name() for input_config in permutations]
    )
    extra_packages = [new_package]
    if not run_inputs_in_parallel:
        config.simulation.model_name = explicit_model_names[0]
        sim_api = surrogate_builder_class.start_simulation_api(
            config=config,
            extra_packages=extra_packages,
            n_cpu=config.n_cpu
        )
    else:
        sim_api = None

    func_kwargs = []
    time_delay_between_starts = config.simulation.dymola_api_kwargs.get("time_delay_between_starts", 0)

    for idx, input_config in enumerate(permutations):
        func_kwargs.append(
            dict(
                config=config,
                input_config=input_config,
                model_name=explicit_model_names[idx],
                surrogate_builder_class=surrogate_builder_class,
                surrogate_builder_kwargs=kwargs,
                sim_api=sim_api,
                use_mp=not run_inputs_in_parallel,
                extra_packages=extra_packages,
                time_delay_to_start=time_delay_between_starts * (idx % config.n_cpu)
            )
        )

    log_paths = bes_rules_mp.execute_function_in_parallel(
        func=run_single_inputs_combination,
        func_kwargs=func_kwargs,
        n_cpu=config.n_cpu,
        use_mp=run_inputs_in_parallel,
        notifier=notify.notify_telegram,
        percentage_when_to_message=20
    )
    notify.notify_telegram(f"Study {config.name} is finished.")

    # Merge result files:
    merged_df_path = merge_result_files(study_config=config)

    # Reproduction
    other_files_to_store = config_files + [merged_df_path]
    files_to_store = get_files_to_store(
        log_paths=log_paths, other_files_to_store=other_files_to_store
    )

    reproduction_kwargs = dict(
        title=config.name,
        path=config.study_path,
        files=files_to_store,
        log_message=log_message
    )
    if isinstance(sim_api, DymolaAPI):
        sim_api.save_for_reproduction(
            save_total_model=False,
            export_fmu=False,
            **reproduction_kwargs
        )
        sim_api.close()
    else:
        save_reproduction_archive(**reproduction_kwargs)


def merge_result_files(study_config: StudyConfig):
    """
    Function to merge result files by adding the input-scenarios as a column.
    """
    dfs = []
    for input_config in study_config.inputs.get_permutations():
        study_name = input_config.get_name()
        log_path = SurrogateBuilder.create_and_get_log_path(
            base_path=study_config.study_path, study_name=study_name
        )

        if not os.path.exists(log_path):
            logger.error("Can not merge %s, no xlsx result file!", study_name)
            continue
        df = SurrogateBuilder.load_design_optimization_log(file_path=log_path)
        for input_name, input_value in input_config.get_name_parts().items():
            df[input_name] = input_value
        dfs.append(df)
    df = pd.concat(dfs)
    path = study_config.study_path.joinpath(f"{study_config.name}_all_results.xlsx")
    sheet_name = "Results"
    df.to_excel(path, sheet_name=sheet_name)
    return path


def get_files_to_store(log_paths: List[Path], other_files_to_store: List[Path]) -> List[CopyFile]:
    files_to_store = []
    for file in log_paths:
        if not os.path.exists(file):
            logger.warning("File for reproduction %s does not exist", file)
            continue
        files_to_store.append(
            CopyFile(filename=f"DesignOptimization/{file.parent.name}/{file.name}",
                     sourcepath=file,
                     remove=False)
        )
    for file in other_files_to_store:
        if not os.path.exists(file):
            logger.warning("File for reproduction %s does not exist", file)
            continue
        files_to_store.append(
            CopyFile(filename=f"InputVariation/{file.name}", sourcepath=file, remove=False)
        )
    return files_to_store
